#include "cmhog.def"
c=======================================================================
c////////////////////////  SUBROUTINE GALAXY  \\\\\\\\\\\\\\\\\\\\\\\\\\
c  defines the potential from either an analytical subroutine
c  (it should define inipotential() and potential() as defined
c   by NEMO), or via up to two grid (FITS) files defining the
c   axisymmetric and  non-axisymmetric parts of the potental
c   on an X-Y grid.
c
      subroutine galaxy
c
c-----------------------------------------------------------------------
#include "param.h"
#include "grid.h"
#include "root.h"
#include "field.h"
c-----------------------------------------------------------------------
      integer i,j,k,ndim,npar
      real arg
      character name*5, pot0*80, pot1*80, errtxt*40,comment*80
      real crval1,crval2,crpix1,crpix2,cdelt1,cdelt2
      real*8 amp,amode,n,aob,qm,rhoc
      real*8 par(8),pos(3),acc(3),pot,dumtime
      integer flun,bsize,status,rwmode,naxes(2)
      logical anyf

      INTEGER nx,ny
      REAL gpot0,gpot1,gcrpix1,gcrpix2,gcdelt1,gcdelt2,gcrval1,gcrval2
      REAL gomega
      COMMON/ggrid/nx,ny,gpot0(PGMAX,PGMAX),gpot1(PGMAX,PGMAX),
     *          grmax,gomega,
     * 		gcrpix1,gcrpix2,gcdelt1,gcdelt2,gcrval1,gcrval2,
     *          grhalo,gvhalo,ggamma

      external inipotential,potential
c\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\////////////////////////////////
c=======================================================================
c
c     assumed that igrav=1 and igeom=1
      namelist /pgen/ amp,npar,amode,n,aob,rl,qm,rhoc,bartime
      namelist /spiral/ spamp,spsc,spang,sppat,sr,pc
      namelist /pgrid/pot0,pot1,naxis1,naxis2,rmax,omega,gamma,
     *                crval1,crval2,crpix1,crpix2,cdelt1,cdelt2,
     *                rhalo,vhalo
      ndim=3
      npar=7
      name='dummy'
      pot0=' '
      pot1=' '
      naxis1=0
      naxis2=0
      crval1=0.0
      crval2=0.0
      cdelt1=1.0
      cdelt2=1.0
      crpix1=1.0
      crpix2=1.0
      rmax=0.0
      omega=0.0
      gamma=1.0
      rhalo=1.0
      vhalo=0.0
      read (1,pgen)
      write(2,pgen)
      read (1,spiral)
      write(2,spiral)
      read (1,pgrid)
      write(2,pgrid)
C
C  there are two modes of using PGRID:    when pot0 given, it will use the external
C  file (a fits file)
C
      if (pot0 .ne. ' ') then
#ifdef FITSIO
	write(*,*) 'Using a grid from an external file: ',pot0
	rwmode = 0
	status = 0
	call ftgiou(flun,status)
	call ftgerr(status,errtxt)

	call ftopen(flun,pot0,rwmode,bsize,status)
	call ftgisz(flun, 2, naxes,status)
	naxis1 = naxes(1)
	naxis2 = naxes(2)
	write(*,*) 'Found image ',naxis1,naxis2
	call ftg2de(flun,0,0.0,PGMAX,naxis1,naxis2,gpot0,anyf,status)
	call ftgerr(status,errtxt)
	call ftgkye(flun,'CRPIX1',crpix1,comment,status)
	call ftgkye(flun,'CRPIX2',crpix2,comment,status)
	call ftgkye(flun,'CRVAL1',crval1,comment,status)
	call ftgkye(flun,'CRVAL2',crval2,comment,status)
	call ftgkye(flun,'CDELT1',cdelt1,comment,status)
	call ftgkye(flun,'CDELT2',cdelt2,comment,status)
	write(*,*) 'ftopen pot0: ',status,' ',errtxt,naxis1,naxis2
	write(*,*) 'X-range: ',(1-crpix1)*cdelt1+crval1,' ...',
     *                    (naxis1-crpix1)*cdelt1+crval1,' kpc.'
	write(*,*) 'Y-range: ',(1-crpix2)*cdelt2+crval2,' ...',
     *                    (naxis2-crpix2)*cdelt2+crval2,' kpc.'
	write(*,*) '(wcs: ',crpix1,crpix2,crval1,crval2,cdelt1,cdelt2,')'
	call ftclos(flun,status)
	call ftgerr(status,errtxt)
	write(*,*) 'ftclos pot0: ',status,' ',errtxt

	call ftopen(flun,pot1,rwmode,bsize,status)
	if (status.eq.0) then
	  call ftgisz(flun, 2, naxes,status)
	  if (naxis1.ne.naxes(1)) stop
   	  if (naxis2.ne.naxes(2)) stop
	  call ftg2de(flun,0,0.0,PGMAX,naxis1,naxis2,gpot1,anyf,status)
	  call ftgerr(status,errtxt)
	  call ftclos(flun,status)
	  call ftgerr(status,errtxt)
	  write(*,*) 'ftclos pot1: ',status,' ',errtxt
        else
          write(*,*) 'No pot1 - only constant axisymmetric potential'
	  do 3 k=1,PGMAX
	  do 3 j=1,PGMAX
		gpot1(j,k) = 0.0
   3	  continue
        endif

	nx = naxis1
	ny = naxis2
	gcrpix1 = crpix1
	gcrpix2 = crpix2
	gcrval1 = crval1
	gcrval2 = crval2
	gcdelt1 = cdelt1
	gcdelt2 = cdelt2
	grmax = 0.0
	gomega = omega
	gvhalo = vhalo
	grhalo = rhalo
	ggamma = gamma
	write(*,*) 'Pattern speed omega = ',omega
	write(*,*) 'Halo: vhalo,rhalo= ',vhalo,rhalo
	write(*,*) 'Disk: gamma= ',gamma
#else
	write(*,*) 'Support for FITSIO was not properly encoded'
	STOP
#endif
C
C  the send mode of using 'pgrid' is setting the number of pixels of the grid,
C  and an internal grid is computed exactly from the analytical potential
C  NEMO routines can also generate those externally on a grid, but this method
C  makes the program independant of NEMO
C
      else if (naxis1.gt.0 .and. naxis2.gt.0) then
					
	write(*,*) 'Using an internal grid; size=',naxis1,naxis2,
     *             ' rmax=',rmax
	nx = naxis1
	ny = naxis2
	gcrpix1 = crpix1
	gcrpix2 = crpix2
	gcrval1 = crval1
	gcrval2 = crval2
	gcdelt1 = cdelt1
	gcdelt2 = cdelt2
	rmax = rmax
	gomega = omega
	write(*,*) 'Pattern speed omega = ',omega
      endif
C
      do 5 i=1,npar
	if (i.eq.1) par(i)=omega
	if (i.eq.2) par(i)=amode
	if (i.eq.3) par(i)=n
	if (i.eq.4) par(i)=aob
	if (i.eq.5) par(i)=rl
	if (i.eq.6) par(i)=0.0
	if (i.eq.7) par(i)=rhoc
5     continue

      call inipotential(npar,par,name)
C   
      if (nyz.gt.1) then
	do 7 k=ks,ke+1
	do 7 j=js-3,je+3
          pos(1)=y(j)*cos(zcenteul(k))
	  pos(2)=y(j)*sin(zcenteul(k))
	  pos(3)=0.0
	  call potential (ndim,pos,acc,pot,dumtime)
	  diskyed(j,k)=(acc(1)*cos(zcenteul(k)))
     &			 +(acc(2)*sin(zcenteul(k)))
	  pos(1)=radius(j)*cos(zcenteul(k))
	  pos(2)=radius(j)*sin(zcenteul(k))
	  call potential (ndim,pos,acc,pot,dumtime)
	  diskycen(j,k)=(acc(1)*cos(zcenteul(k)))
     &			  +(acc(2)*sin(zcenteul(k)))
7       continue
      endif
c
      par(6)=qm
      call inipotential(npar,par,name)
c
      if (nyz.gt.1) then
	do 9 k=ks,ke+1
	do 9 j=js-3,je+3
          pos(1)=y(j)*cos(zcenteul(k))
	  pos(2)=y(j)*sin(zcenteul(k))
	  pos(3)=0.0
	  call potential (ndim,pos,acc,pot,dumtime)
	  baryed(j,k)=(acc(1)*cos(zcenteul(k)))
     &			+(acc(2)*sin(zcenteul(k)))
	  pos(1)=radius(j)*cos(zcenteul(k))
	  pos(2)=radius(j)*sin(zcenteul(k))
	  call potential (ndim,pos,acc,pot,dumtime)
	  barycen(j,k)=(acc(1)*cos(zcenteul(k)))
     &			 +(acc(2)*sin(zcenteul(k)))
          if (y(j).gt.sr) then
            arg=2.0*((log(y(j)-sr)/tan(spang))-zcenteul(k))+pc
            spyed(j,k)=-spamp*(y(j)-sr)**2*exp(-spsc*(y(j)-sr))*
     &                ((3.0-spsc*(y(j)-sr))*cos(arg)-
     &                (2.0/tan(spang))*sin(arg))
          else
            spyed(j,k)=0.0
          endif
c          if (y(j).gt.16.) then
c            spyed(j,k)=spyed(j,k)*exp(16.0-y(j))
c          endif
          if (radius(j).gt.sr) then
            arg=2.0*((log(radius(j)-sr)/tan(spang))-zcenteul(k))+pc
            spycen(j,k)=-spamp*(radius(j)-sr)**2*
     &                 exp(-spsc*(radius(j)-sr))*
     &                 ((3.0-spsc*(radius(j)-sr))*cos(arg)-
     &                 (2.0/tan(spang))*sin(arg))
          else
            spycen(j,k)=0.0
          endif
c          if (radius(j).gt.16.) then
c            spycen(j,k)=spycen(j,k)*exp(16.0-radius(j))
c          endif
9       continue
      endif
C
      if (nzz.gt.1) then
	do 10 j=js,je
	do 10 k=ks-1,ke+1
          pos(1)=radius(j)*cos(z(k))
	  pos(2)=radius(j)*sin(z(k))
	  pos(3)=0.0
	  call potential (ndim,pos,acc,pot,dumtime)
	  barzed(j,k)=(acc(1)*sin(z(k)))-(acc(2)*cos(z(k)))
	  pos(1)=radius(j)*cos(zcenteul(k))
	  pos(2)=radius(j)*sin(zcenteul(k))
	  call potential (ndim,pos,acc,pot,dumtime)
	  barzcen(j,k)=(acc(1)*sin(zcenteul(k)))
     &			 -(acc(2)*cos(zcenteul(k)))
          if (radius(j).gt.sr) then
            arg=2.0*((log(radius(j)-sr)/tan(spang))-z(k))+pc
            spzed(j,k)=-2.0*spamp*(radius(j)-sr)**2*
     &                 exp(-spsc*(radius(j)-sr))*sin(arg)
            arg=2.0*((log(radius(j)-sr)/tan(spang))-zcenteul(k))+pc
            spzcen(j,k)=-2.0*spamp*(radius(j)-sr)**2*
     &                 exp(-spsc*(radius(j)-sr))*sin(arg)
          else
            spzed(j,k)=0.0
            spzcen(j,k)=0.0
          endif
c          if (radius(j).gt.16.) then
c            spzed(j,k)=spzed(j,k)*exp(16.0-radius(j))
c            spzcen(j,k)=spzcen(j,k)*exp(16.0-radius(j))
c          endif
10     continue
      endif
c
      do 11 k=ks,ke
      do 11 j=js,je
	d(j,k)=amp
	w(j,k)=sqrt(abs(radius(j)*diskycen(j,k)))
11    continue
      vgz=par(1)
      vspiral=sppat-vgz
C
c      open (unit=7,file='spforces.dat')
c      do 12 k=ks,ke
c      do 12 j=js,je
c       write (7,13) diskycen(j,k),spycen(j,k),spzcen(j,k) 
c13     format (3e14.5) 
c12    continue
c      close (unit=7)
c      stop 
      return
      end
