%\documentstyle[11pt,epsf]{article}
%\documentstyle[11pt,epsf]{report}
%\documentclass[11pt,epsf]{report}
\documentclass[11pt]{article}
\usepackage{epsfig}

\pagestyle{myheadings}

% Some definitions I use in these instructions.

\def\emphasize#1{{\sl#1\/}}
\def\arg#1{{\it#1\/}}
\let\prog=\arg

\def\edcomment#1{\iffalse\marginpar{\raggedright\sl#1\/}\else\relax\fi}
\marginparwidth 1.25in
\marginparsep .125in
\marginparpush .25in
\reversemarginpar

\title{Using CMHOG with NEMO and MIRIAD}
\author{Peter Teuben}
% \affil{Astronomy Department, University of Maryland, College Park, MD 20742, USA}


\begin{document}

\maketitle


\begin{abstract}

An overview is given how to use and extend 
the Piner, Stone \& Teuben (1995, ApJ 449, 508) hydro code
{\tt cmhog}, and in particular how HDF output data can be used with
NEMO and MIRIAD for some basic visualization and data analysis.
Only single runs are covered, restart runs are not discussed.

\end{abstract}

\section{Introduction}

The ``{\tt cmhog}'' code is an isothermal PPM code, 
that was adopted to run a 2-dimensional polar-grid gas flow in a 
barred galaxy (Piner, Stone \& Teuben, 1995 ApJ 449, 508).
Because of symmetry, only half of the plane is
simulated, with the appropriate  boundary condition.
The bar is elongated along the Y-axis, with 
counter clockwise gas flow. Initially the bar is absent, but
slowly (usually 0.1Gyr) turned on while keeping
the total mass constant. The simulation
is usually followed for 1-2 Gyr, to settle into a quasi-stationary
state, at which time the gas properties (density, flow velocities)
can be studies and compared to observations.

\section{The ``cmhogin'' input file}

The {\tt cmhog} program uses a classic, but not often used, method of parameter input
that is a little more rubust to errors than the more often (ab)used method
of reading information from standard input. It's called {\tt namelist}\index{namelist},
a specially formatted textfile, 
and works roughly like magically reading a FORTRAN named common block. 

\subsection{For the programmer}

For the programmer it is very convenient to pass parameters via a namelist.
After opening the unit somewhere at the beginning of the program
(cmhog does this in mstart.src) various subroutines can simply read
the namelist  that they need.

\begin{verbatim}
    open(unit=1,file='cmhogin' ,status='old')                     ::mstart.src

    real*8 amp,amode,n,aob,qm,rhoc				  ::galaxy.src
    real   bartime
    namelist /pgen/ amp,npar,amode,n,aob,rl,qm,rhoc,bartime       
    read (1,pgen)                                                 

    logical lgrid
    namelist /ggen2/ nbl,ymin,ymax,igrid,yrat,dymin,vgy,lgrid	  ::ggen.src
    namelist /ggen3/ nbl,zmin,zmax,igrid,zrat,dzmin,vgz,lgrid
    read (1,ggen2)




\end{verbatim}

\subsection{For the user}

For the user this means all parameters are set in a simple ascii file
named ``{\tt cmhogin}'' that can be edited. This file must be in the
current directory when {\tt cmhog} starts to run (see also
{\tt runcmhog} below).

\begin{verbatim}

 $rescon  $
 $hycon idiff=1,ifltn=1,tlim=2.0 $
 $ggen2 nbl=132,ymin=0.1,ymax=16.0,yrat=1.03926991,igrid=1,lgrid=.true. $
 $ggen3 nbl=80,zmin=-1.5708,zmax=1.5708,igrid=1,lgrid=.true. $
 $ijb $
 $ojb $
 $ikb $
 $okb $
 $eos ciso=5.0 $
 $pgen amp=10.0,amode=1.0,n=1.0,aob=2.5,rl=6.0,qm=4.5e4,rhoc=2.4e4,bartime=0.1 $
 $spiral spamp=0.0,spang=-0.5236,spsc=1.0,sppat=32.74,sr=4.0,pc=2.328 $
 $iocon dthdf=0.1,dtmovie=5.0,dthist=0.01 $
 $mlims cma1=3.0,cmi1=-2.0,cma2=200.0,cmi2=-200.0,cma3=200.0,cmi3=-200.0 $

\end{verbatim}

When {\tt cmhog} finishes, the file {\tt cmhogout} will reflect the full
status of the namelist, not just the variables entered via the {\tt cmhogin}
file.

The most common ones to modify are (geometry in {\tt ggen2} and {\tt ggen3}
will be dicussed later)

\begin{itemize}

\item
{\tt pgen::aob}
Axis ratio $a/b$ of the bar, note it will be $> 1$.

\item
{\tt pgen::rl}
Lagrangian radius, in kpc. This sets the pattern speed.

\item
{\tt pgen::qm}
Quadropole moment, this sets the mass fraction of the bar.

\item
{\tt pgen::rhoc}
Central density, this sets 

\item
{\tt pgen::bartime}
Time for the bar to (linearly) grow to full strength (in Gyr)

\item
{\tt iocon::dthdf}
Timestep for HDF data dumps (in Gyr)

\item
{\tt icon::dtmovie }
Timestep for {\tt mde/mvt/mvr} data dumps (in Gyr)

\item
{\tt icon::dthist}
Timestep in {\tt history} file (in Gyr)

\item
{\tt hycon::tlim}
Stop time of the integration (in Gyr)

\end{itemize}


\subsection{Choice of the grid}

{\Large THE MATH IN THIS SECTION IS ACTUALLY WRONG, DON''T USE IT}
\bigskip

The grid is a polar grid, and set by the {\tt ggen2} (radial) and 
{\tt ggen3} (angular) namelist entries, of which the {\tt min} and
{\tt max} variables control the centers of the cells:

\begin{verbatim}
 $ggen2 nbl=132,ymin=0.1,ymax=16.0,yrat=1.03926991,igrid=1,lgrid=.true. $
 $ggen3 nbl=80,zmin=-1.5708,zmax=1.5708,igrid=1,lgrid=.true. $
\end{verbatim}

although there are 7 essential variables in these 
two namelist entries, not all should be choosen freely. 
One possibilty is to choose the 3 radial extent variables
and derive the remainder from some constraints :


\begin{enumerate}
\item
choose  {\tt ggen2::ymin} = $y_{min}$, the inner boundary of the grid (in kpc)
??? is this the radial center of the inner most cell, or the inner boundary???
if it's the center, what is really the correct formulae for the stuff derived below.
that will have to change slightly.

\item
choose {\tt ggen2::ymax} = $y_{max}$, the outer boundary of the grid (in kpc)
??? is this the radial center of the out most cell, or the outer boundary???

\item
choose {\tt ggen2::nbl} = $N_y$, the number of radial zones.

\item
compute {\tt ggen2::yrat} = $y_{rat}$ from the following formulae:
$$
	 y_{rat} = {y_{max} \over y_{min}}^{1/{N_y}}
$$

\item
Compute {\tt ggen3::nbl} = $N_z$, the number of angular zones, such that cells are 
close to being square from the following relationship that equates the two:
$$
	{{\pi y_{min}} \over N_z} = (y_{rat} - 1 ) y_{min}
$$
or
$$
N_z =   {  {\pi y_{min}  }   \over  { (y_{rat} - 1 ) y_{min} } }
$$

\item
Compute {\tt ggen3::zmax} = $z_{max}$ from
$$
	( \pi - z_{max} ) 2 = {\pi \over N_z}, ~~~~~ or,~~~~~~~
	z_{max} = \pi ( 1 - {1 \over {2 N_z}})
$$

\item
Compute {\tt ggen3::zmin} = $z_{min}$ from
$$
	( z_{min} + \pi ) 2 = {\pi \over N_z}, ~~~~~~ or,~~~~~~~
	z_{min} = - z_{max} 
$$



\end{enumerate}

In case we got the boundaries wrong, the following is more appropriate: 
$r_0$ is the inner boundary, $r_N$ the outer, and $f=1+\epsilon$ the
geometric factor called {\tt yrat} earlier.
$$
r_i = r_{i-1} f, ~~~ i=1..N
$$
thus
$$
r_N = r_0 f^N
$$
and since
$$
r_{min} = (r_0+r_1)/2,     ~~~~~ r_{max} = (r_{N-1}+r_N)/2
$$
we get
$$
r_{min} = r_0 (1+f)/2,   ~~~~~ r_{max} = r_{min} f^{N-1}
$$
or
$$
r_0 = { 2 \over  { 1+f}}  r_{min}, ~~~~  r_N = r_O f^N
$$


Here are some formulae that we know are correct:

$$
      r_1 = r_0 + dr, ~~  r_2 = r_1 + dr f  ~~...~~ r_N = r_{N-1} + dr f^{N-1}
$$
or following standard summation series (see e.g. G\&R, or Abramowitz)
$$
	r_N = r_0 + dr \sum_{k=0}^{N-1}{f^k} = r_0 + dr { {f^N-1} \over { f - 1 }}
$$
and
$$
     dr =  (r_N - r_0) { {f-1} \over { f^N - 1 }}
$$



\section{Output}

For the remainder of the discussion, we will assume all data produced
by {\tt cmhog} is dumped in a run-directory. 
Depending on options given to the program, you will find the following files:

\begin{itemize}

\item
{\tt cmhogin}
Input namelist, that controls the program.

\item
{\tt cmhogout}
Output namelist, reflects current state of all variables.

\item
{\tt history}
Ascii table with time in the first column, other columns 
are used for things such as mass loss across the inner and 
outer boundaries etc.etc.

\item
{\tt hdfXXXbg}
Full HDF dataset, in SDS format (Scientific Data Set), typically
with three named ``fields'': the 
{\tt R-VELOCITY}, {\tt PHI-VELOCITY}, and {\tt DENSITY}.
The NEMO program {\tt tsd} will display the contents of
such SDS files. Each file contains information for one timestep.
{\tt hdf000bf} is normally the first one, for $t=0$ at the beginning
of the simulation.

\item
{\tt mdeXXXbg}
Sample X-Y gridded density in a 8bit deep image

\item
{\tt mvrXXXbg}
Sample X-Y gridded radial velocity in a 8bit deep image

\item
{\tt mvtXXXbg}
Sample X-Y gridded tangential in a 8bit deep image

\end{itemize}

\section{NEMO programs}

Most, if not all, NEMO programs come with a manual page that should
explain the command line parameters (keywords) in more detail.

\subsection{runcmhog}

{\tt cmhog} is a program that needs to be run in a clean directory, and you
cannot run another {\tt cmhog} in that directory. That is because the names
of files that {\tt cmhog} produces are FIXED by the program, and cannot be
changed even by the {\tt cmhogin} file (it is also not practical to do that).
To help running {\tt cmhog}, a small pre-processor was written, called
{\tt runcmhog}. It is a little C program available in NEMO with which you
can use a template {\tt cmhogin} file and override parameters and set
a run directory, e.g.

\begin{verbatim}
    % runcmhog -n cmhogin.small run001  aob=2.0
    % runcmhog -n cmhogin.small run002  aob=2.5
    % runcmhog -n cmhogin.small run003  aob=3.0
    % runcmhog -n cmhogin.small run004  aob=3.5
\end{verbatim}

Jianjun Xu (a student of Jim Stone) once wrote a nice graphical frontend,
based on Tcl/Tk, to parse and generate cmhogin files. The code still
exists, but has not been excersized in a long time.

\subsection{tsd}

{\tt tsd} scans an HDF SDS :
\footnotesize\begin{verbatim}
% tsd hdf001bg 
Found 3 scientific data sets in run001/hdf001bg
1: R-VELOCITY AT TIME=1.00E-01(20,37) km/sec  -> [740 elements of type: 5 (FLOAT32)]
2: PHI-VELOCITY AT TIME=1.00E-01(20,37) km/sec  -> [740 elements of type: 5 (FLOAT32)]
3: DENSITY AT TIME=1.00E-01(20,37) Msolar/pc**2  -> [740 elements of type: 5 (FLOAT32)]
\end{verbatim}\normalsize

but can also print out data values and the coordinate system. In our case, the
first axis is the radial coordinate, and will not be a regularly sampled axis. The
second axis is the angular coordinate, and will be regularly samples
(normally between $-\pi/2$ and $\pi/2$).

\begin{figure}[htbp]
\epsfysize=5cm
\epsfbox{denrt.ps}
\caption{
Logarithmic density in polar coordinates:\newline
  \tt \% sdsfits hdf200bg mapd.fits 3\newline
  \tt \% fitsccd mapd.fits - | ccdmath - - 'log(\%1)' | ccdplot - yapp=denrt.ps/vps
}

\end{figure}

\begin{figure}[htbp]
\epsfysize=5cm
\epsfbox{denxy.ps}
\caption{
Logarithmic density in cartesian coordinates:\newline
  \tt \% hdfgrid hdf200bg - 3 | ccdmath - - 'log(\%1)' | ccdplot - yapp=den.ps/vps
}
\end{figure}

\subsection{sdsfits}

The individual ``fields'' from an {\tt hdfXXXbg} files can be converted to FITS files,
for visual inspection. Just remember that the first axis is the radial axis, the
second one the angular.  A ring will thus show up as a vertical structure.

\footnotesize\begin{verbatim}
% sdsfits hdf001bg map001vr.fits 1
% sdsfits hdf001bg map001vt.fits 2
% sdsfits hdf001bg map001de.fits 3
\end{verbatim}\normalsize

Here is another plot:
\footnotesize\begin{verbatim}
% fitsccd mapd.fits - | ccdmom - - axis=2 mom=0 | ccdprint - x= newline=t | tabplot - 0 1 line=1,1
\end{verbatim}\normalsize
it plots total density averaged in rings, as function of cell.

\subsection{hdfgrid}

{\tt hdfgrid}
regrids selected gas properties from our 
HDF files into a cartesian coordinate system. 
It is specific to this polar-coordinate problem.

\footnotesize\begin{verbatim}
% hdfgrid hdf001bg map000de.ccd zvar=den
% hdfgrid hdf001bg map000vr.ccd zvar=vr
% hdfgrid hdf001bg map000vt.ccd zvar=vt
% hdfgrid hdf001bg map000vx.ccd zvar=vx
% hdfgrid hdf001bg map000vy.ccd zvar=vy
\end{verbatim}\normalsize

Note that the {\tt vx} and {\tt vy} velocity fields
are computed on the fly. Nearest neighbor cells are
used for bi-linear interpolation. Some assumptions
about the symmetry properties of the variables
have been made.



\section{flowcode}

Although gas flow in a barred galaxy never reaches an
exact steady state, it does approach something
that can perhaps be called a QSSS. However, another approach
to understand the gas flow is take a particular snapshot, and
integrate test particles in the velocity field, i.e.
solve the equations
$$
	{dx \over dt } = V_x(x,y)
$$
and
$$
	{dy \over dt } = V_y(x,y)
$$
NEMO's {\tt flowcode} program does that. For this a special
``vrt'' file (NEMO image format) is needed as input for the
integrator, consisting
of two 2D images with VR and VT, followed by two 1D images
with the coordinates in Radius and Polar Angle (called PHI)
A ``vrt'' map is created with a script {\tt mkvrt}.

\subsection{NEMO scripts: mkbar}

Shell scripts are probably currently the easiest way to setup
problems. In order to make them reusable, much like NEMO
programs, they should take a series of {\it ``keyword=value''}
command line arguments.

\footnotesize\begin{verbatim}
#! /bin/csh -f
#
#
#> nemo.need mkconfig snapadd snapscale snaprotate snapspin

# bar length and axis ratio of bar
set b=1.4
set q=0.2

# 
set n=100

# derived quantities
set phi=`nemoinp "atand($q)"`

rm bulge line1 line2 bar disk model.dat

mkconfig - $n shell "$q*$b" | snapscale - bulge 1 1,1,0.4
mkconfig - $n line $b | snaprotate - -  90-$phi z | snapshift - line1 "-$q*$b,0,0"
mkconfig - $n line $b | snaprotate - - -90-$phi z | snapshift - line2 "$q*$b,0,0"
mkconfig - $n ring $b | snapscale - bar 1 $q,1,1
mkconfig - $n ring 2  | snapspin - disk 1
snapadd disk,bulge,line1,line2,bar model.dat 

\end{verbatim}\normalsize

\begin{figure}[htbp]
\epsfysize=5cm
\epsfbox{model1.ps}
\caption{Face on view of a simple schematic for a counter-clockwise
rotating bar, as is used in the hydro models:\newline
 \tt \% snapplot model.dat yapp=model1.ps/vps
}
\end{figure}

\subsection{NEMO scripts: project}
 
Projecting a bar to match observations takes 3 geometric parameters:
position angle and inclination of the galactic disk, and position
angle of the bar. In addition there will be centering (xpos,ypos,vsys)
and scaling (pscale, vscale) parameters, that will come later. To
aid in figuring out the geometric projection, a script {\tt project}
was written, that projects the model from the previous section. It
is somewhat taylored for the way we measure angles in astronomy.

\footnotesize\begin{verbatim}
#! /bin/csh -f 
#
#> SCALE inc=0		0:90:1
#> RADIO rotation=ccw   ccw,cw
#> SCALE pa=0		-180:180:1
#> SCALE phi=0		-90:90:1
#> RADIO yapp=/xs       /xs,/vps,/ps
#> ENTRY text=  


foreach a ($*)
  set $a
end

if ($rotation == "cw") then
  snaprotate model.dat - "atand(tand($phi)/cosd($inc+180)),$inc+180,$pa" zyz |\
    snapplot - psize=vz/4 yapp=$yapp xlabel="inc=$inc ($rotation) pa=$pa phi=$phi" "ylabel=$text"
else
  snaprotate model.dat - "atand(tand($phi)/cosd($inc)),$inc,$pa+180" zyz |\
    snapplot - psize=vz/4 yapp=$yapp xlabel="inc=$inc ($rotation) pa=$pa phi=$phi" "ylabel=$text"
endif

\end{verbatim}\normalsize

This script uses NEMO's {\tt tkrun} interface, so you need to run it
as follows:

\footnotesize\begin{verbatim}
    % tkrun project
\end{verbatim}\normalsize

\subsection{NEMO scripts: mkbar\_cube\_ref.csh}

The script listed below is an older one where the geometry (cw/ccw) was not 
properly programmed, but included for completeness. It will use a reference
cube ({\tt n4303cube.fits}) to aid in matching up the theoretical data with
an observation.

\footnotesize\begin{verbatim}
#! /bin/csh -f
#
#  This scripts takes an HDF output snapshot file from cmhog
#  (bar hydro, polar coordinates), projects it to a requested
#  sky view, and using WIP summarizes the results
#  Bar is conveniently oriented along Y axis (PA=0), and flows CCW.
#  For CW rotating galaxies you may have to add 180 to 'inc' and/or 'pa'
#
#
#  23-sep-95	Created				Peter Teuben
#  15-nov-95    beam=0.2 frang=45
#  24-nov-95    defaults for more central region, fixed dependancies
#   9-jul-96    hacking for N5383 
#  24-jul-00    BIMA proposal N4303 et al.
#   5-sep-00    modified to write cubes instead of moment maps
#  12-mar-01    radecvel=t to make karma swallow these fits files
#  13-mar-01    use phi,inc,pa (no more +/- 180) and documented geometry
#               (notice that earlier versions had sign of radial vel wrong)
#  23-mar-01    added a refmap and fixed refscale; this assumes that the refmap
#		(often a cube) has the reference pixel defined to the be 
#		center of the galaxy (bimasong data often don't do the VELO axis correct)
#  17-apr-01    added velocity referencing using 'vsys' to be at v=0 in the model cube
#               (bugs when model and data have different delta-V)

if ($#argv == 0) then
  echo Usage: $0 in=HDF_DATASET out=BASENAME ...
  echo Gridding and projecting 2D CMHOG hydro models to given bar viewing angles
  exit 0
endif

# 			Required Keywords
unset in
unset out
# 			Defaulted Keywords
set pa=0
set inc=0
set phi=0
set rmax=6
set n=200
set beam=0.05
set color=1
set clean=1
set refmap=n4303cube.fits
set pscale=0.5
set vscale=1
set vsys=0
#			Velocity gridding for cube  (dv=2*vmax/nvel)
set nvel=50
set vmax=250

#			Parse commandline to (re)set keywords
foreach a ($*)
  set $a
end
#			Show i'm happy
echo Files: in=$in out=$out 
echo Grid: rmax=$rmax n=$n beam=$beam
echo Projection: phi=$phi inc=$inc pa=$pa
#                       Derived quantities
set cell=`nemoinp "2*$rmax/$n"`
set range="-${rmax}:${rmax}"
echo "      Derived: cell=$cell"


#   referencing 
set nz=(`fitshead $refmap | grep ^NAXIS3 | awk '{print $3}'`)
set pz=(`fitshead $refmap | grep ^CRPIX3 | awk '{print $3}'`)
set vz=(`fitshead $refmap | grep ^CRVAL3 | awk '{print $3}'`)
set dz=(`fitshead $refmap | grep ^CDELT3 | awk '{print $3}'`)

set dz1=`nemoinp "2000*$vmax/$nz"`
set vref=`nemoinp "($vz-1000*$vsys)/($dz1)+$nvel/2+0.5"`
#set vscale=`nemoinp "$vscale*(2*$vmax/$nvel)/($dz/1000)"`
set refscale=$pscale,$pscale,$vscale
#                                    CHECK : is this -0.5 or +0.5   ?????
set refcen=`nemoinp $n/2-0.5`
#set refpix=$refcen,$refcen,$vref


#   now assuming model is centered, as well as data cube
set vref=`nemoinp $nvel/2+0.5`
###set vref=`nemoinp $nvel/2-0.5`
set refpix=$refcen,$refcen,$vref


echo $nz $pz $vz $dz 
echo Vsys at OBS pixel: `nemoinp "(1000*$vsys-$vz)/$dz+$pz"` 
echo REFPIX:   $refpix
echo REFSCALE: $refscale


#> nemo.need tabtos snaptrans snaprotate snapadd snapgrid ccdsmooth ccdmath ccdfits fitshead

set tmp=tmp$$
if (! -e $out.den.fits) then

    # convert the half-plane HDF file to a full plane snapshot file

    tsd in=$in out=$tmp.tab coord=t
    if ($status) goto cleanup
    tabtos in=$tmp.tab out=$tmp.s0 block1=x,y,vx,vy,mass
    snaptrans in=$tmp.s0 out=$tmp.s1 ctypei=cyl ctypeo=cart
    snaprotate in=$tmp.s1 out=$tmp.s2 theta=180 order=z
    snapadd $tmp.s1,$tmp.s2 $tmp.s3

    # project for skyview, and create a intensity and velocity field

    snaprotate $tmp.s3 $tmp.snap \
        "atand(tand($phi)/cosd($inc)),$inc,$pa" zyz

    foreach mom (0 1 2)
         snapgrid in=$tmp.snap out=$tmp.$mom \
                xrange=$range yrange=$range nx=$n ny=$n moment=$mom mean=t
         ccdsmooth in=$tmp.$mom out=$tmp.$mom.s gauss=$beam
    end
    ccdmath $tmp.1.s,$tmp.0.s $tmp.vel %1/%2
## BUG: ifgt() doesn't work
##    ccdmath $tmp.0.s - "ifgt(%1,0,log(%1),-10)" | ccdfits - $out.den.fits
    ccdmath $tmp.0.s - "log(%1)" | ccdmath - - "ifeq(%1,0,-10,%1)" | ccdfits - $out.den.fits  \
        object=$in comment="$0 $in $out $pa,$inc,$phi,$range,$n,$beam"  \
	refmap=$refmap scale=$refscale refpix=$refpix
    ccdmath $tmp.2.s,$tmp.0.s,$tmp.vel - "sqrt(%1/%2-%3*%3)" | ccdfits - $out.sig.fits \
        object=$in comment="$0 $in $out $pa,$inc,$phi,$range,$n,$beam" 	\
	refmap=$refmap scale=$refscale refpix=$refpix
    ccdfits $tmp.vel $out.vel.fits \
        object=$in comment="$0 $in $out $pa,$inc,$phi,$range,$n,$beam" 	\
	refmap=$refmap scale=$refscale refpix=$refpix


### BUG:      ccdmath - - "ifgt(%1,0,log(%1),-10)" |\


    # now also create the (smoothed) cube
    snapgrid in=$tmp.snap out=- \
          xrange=$range yrange=$range zrange=-${vmax}:${vmax} \
	  xvar=x yvar=y zvar=-vz \
	  nx=$n ny=$n nz=$nvel moment=0 mean=t |\
      ccdsmooth - - gauss=$beam |\
      ccdmath - - "log(%1)" |\
      ccdmath - - "ifeq(%1,0,-10,%1)" |\
      ccdfits - $out.cube.fits \
        object=$in comment="$0 $in $out $pa,$inc,$phi,$range,$n,$beam" \
	refmap=$refmap scale=$refscale refpix=$refpix

    rm -fr $tmp.*
else
    echo Warning: skipping gridding and projecting
endif
exit 0

cleanup:
    if ($clean) rm $tmp.*

\end{verbatim}\normalsize



\section{cmhog: the Program}

Files are .src (fortran source to be pre-processed by cpp) and 
.inc (for the preprocessor) and .h (standard fortran includes).

\begin{verbatim}
    main    
        mstart
	    setup
	    grid_generator    (ggen)
	    problem_generator (galaxy)
	    nudt
        dataio
	
	solver
	intchk
	dataio
	special
	nudt
	
	dataio
\end{verbatim}

\section{Installation}

The best way to obtain {\tt cmhog} is via 
anonymous CVS\footnote{See {\tt http://www.astro.umd.edu/~teuben/miriad/cvs.html}
for more details on CVS usage}: 

\begin{verbatim}
	cvs -d :pserver:anonymous@cvs.astro.umd.edu:/home/cvsroot login
		(no password required, just hit ENTER)
	cvs -d :pserver:anonymous@cvs.astro.umd.edu:/home/cvsroot co cmhog2
		(this will create a cmhog directory)
	cd cmhog2
	configure
	make cmhog
	make bench

NOTES:
	does not compile with gcc-3.0 ???
\end{verbatim}

\subsection{Benchmark}

The benchmark within {\tt cmhog} is defined as running the
standard PST95 model through the bar growth time, 0.1Gyr,
on a small $67 \times 40$ grid (see {\tt cmhogin.bench}).
The results for a few popular machines are summarized
in Table 1.

\begin{table}[htbp]
\caption[cmhog code benchmarks]{cmhog code Benchmarks}
\centering
\medskip
\begin{tabular}{|l|r|l|l|l|} \hline
Machine      & MHz  	      & cpu(sec) & 1GHz-Rating & comments \\ 
&&&&  \\ \hline
P-IV/512	& 2200	&	26.3 & 57.8 & g77 -g -O2 \\
                &       &       20.6 &      & ifc -O \\
P-IV		& 2000  &	29.4 & 58.8 &  \\
P-IV		& 1800  &	32.4 & 58.3 &  \\
P-III Coppermine & 933   &	56.6 & 52.8 & \\
                 &       &      40.8 &      & ifc -O \\
P-III		& 700   &	75.2 & 52.6 & \\
P-III		& 600	&	91.1 & 54.7 & \\
 		& 	&	65.0 &      & ifc -O \\
P-III/512 Katmai & 500  &	106.5 & 53.3 & \\
Alpha EV67	& 666   &             &      & bad compiler? \\
AMD 		& 1600  &             &      & \\
Ultra-SPARC-IIi &  440  &	      &      & g77 -g -O2\\
		&  	&	 66.0 & 29.0 & f77 -O \\
		&  	&	 55.0 & 24.2 & f77 -fast \\
 \hline
\end{tabular}
\end{table}

A few ``2002'' comments:
\begin{itemize}
\item An Ultra-SPARC is about twice as efficient as an Intel chip.

\item The Pentium-iii is about 10-15\% more efficient per clock cycle
than the Pentium-iv.

\item The Intel compiler is about 30-40\% more efficient compared
to the GNU compiler.

\end{itemize}

\end{document}

\footnotesize\begin{verbatim}
\end{verbatim}\normalsize


\begin{verbatim}
\end{verbatim}






